"""Project initialization helpers for /init."""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Dict, Iterable, List, Optional

DEFAULT_INIT_FILENAME = "CLAUDE.md"
INIT_FILE_ALIASES = {
    "claude": "CLAUDE.md",
    "gemini": "GEMINI.md",
    "mycoder": "MYCODER.md",
}
IGNORE_ROOT_ENTRIES = {
    ".git",
    ".mycoder",
    ".pytest_cache",
    "__pycache__",
    ".venv",
    "node_modules",
}


def generate_project_guide(root: Path) -> str:
    """Return a markdown guide template for the given project root."""
    info = _collect_project_info(root)
    name = info["name"]
    description = info.get("description") or "TODO"
    tech = info.get("tech") or []
    layout = info.get("layout") or []
    commands = info.get("commands") or []

    lines: List[str] = [
        "# Project Guide",
        "",
        "Generated by MyCoder /init. Update this file with project-specific context.",
        "",
        "## Project Summary",
        f"- Name: {name}",
        f"- Description: {description}",
        f"- Root: {root.name}",
        "",
        "## Tech Stack",
        f"- {', '.join(tech)}" if tech else "- TODO",
        "",
        "## Layout",
    ]
    if layout:
        lines.extend(f"- {entry}" for entry in layout)
    else:
        lines.append("- TODO")
    lines.extend(
        [
            "",
            "## Commands",
        ]
    )
    if commands:
        lines.extend(f"- `{cmd}`" for cmd in commands)
    else:
        lines.append("- TODO")
    lines.extend(
        [
            "",
            "## Notes for MyCoder",
            "- Prefer existing scripts and tools when available.",
            "- Call out risky changes, config updates, and data migrations.",
            "- Keep tests updated and list how to run them.",
        ]
    )

    return "\n".join(lines).rstrip() + "\n"


def _collect_project_info(root: Path) -> Dict[str, object]:
    pyproject = _read_text(root / "pyproject.toml")
    package_json = _read_json(root / "package.json")
    name = (
        _extract_pyproject_value(pyproject, "name")
        or _extract_package_value(package_json, "name")
        or root.name
    )
    description = (
        _extract_pyproject_value(pyproject, "description")
        or _extract_package_value(package_json, "description")
        or _extract_readme_summary(root)
    )

    tech = _detect_tech(root)
    layout = _summarize_layout(root)
    commands = _detect_commands(root, package_json, pyproject)

    return {
        "name": name,
        "description": description,
        "tech": tech,
        "layout": layout,
        "commands": commands,
    }


def _read_text(path: Path) -> str:
    if not path.exists():
        return ""
    try:
        return path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""


def _read_json(path: Path) -> Dict[str, object]:
    text = _read_text(path)
    if not text:
        return {}
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {}


def _extract_pyproject_value(text: str, key: str) -> Optional[str]:
    if not text:
        return None
    for section in ("[project]", "[tool.poetry]"):
        value = _extract_toml_section_value(text, section, key)
        if value:
            return value
    return _extract_toml_key(text, key)


def _extract_toml_section_value(text: str, section: str, key: str) -> Optional[str]:
    in_section = False
    for raw_line in text.splitlines():
        line = raw_line.strip()
        if line.startswith("[") and line.endswith("]"):
            in_section = line == section
            continue
        if not in_section or not line or line.startswith("#"):
            continue
        match = re.match(rf"{re.escape(key)}\s*=\s*['\"]([^'\"]+)['\"]", line)
        if match:
            return match.group(1).strip()
    return None


def _extract_toml_key(text: str, key: str) -> Optional[str]:
    match = re.search(rf"(?m)^{re.escape(key)}\s*=\s*['\"]([^'\"]+)['\"]", text)
    if match:
        return match.group(1).strip()
    return None


def _extract_package_value(package_json: Dict[str, object], key: str) -> Optional[str]:
    value = package_json.get(key)
    if isinstance(value, str) and value.strip():
        return value.strip()
    return None


def _extract_readme_summary(root: Path) -> Optional[str]:
    for filename in ("README.md", "README.rst", "README.txt"):
        text = _read_text(root / filename)
        if not text:
            continue
        heading = _first_heading(text)
        if heading:
            return heading
        paragraph = _first_paragraph(text)
        if paragraph:
            return paragraph
    return None


def _first_heading(text: str) -> Optional[str]:
    for line in text.splitlines():
        stripped = line.strip()
        if stripped.startswith("#"):
            return stripped.lstrip("#").strip()
    return None


def _first_paragraph(text: str) -> Optional[str]:
    buffer: List[str] = []
    for line in text.splitlines():
        stripped = line.strip()
        if not stripped:
            if buffer:
                return " ".join(buffer).strip()
            continue
        if stripped.startswith(("```", ">")):
            continue
        buffer.append(stripped)
    if buffer:
        return " ".join(buffer).strip()
    return None


def _detect_tech(root: Path) -> List[str]:
    tech: List[str] = []
    if (root / "pyproject.toml").exists() or (root / "requirements.txt").exists():
        tech.append("python")
    if (root / "package.json").exists():
        tech.append("node")
    if (root / "go.mod").exists():
        tech.append("go")
    if (root / "Cargo.toml").exists():
        tech.append("rust")
    if (root / "Dockerfile").exists() or list(root.glob("docker-compose*.yml")):
        tech.append("docker")
    if (root / "Makefile").exists():
        tech.append("make")
    return tech


def _summarize_layout(root: Path, limit: int = 12) -> List[str]:
    entries: List[str] = []
    for path in sorted(root.iterdir(), key=lambda p: p.name.lower()):
        if path.name in IGNORE_ROOT_ENTRIES or path.name.startswith("."):
            continue
        name = f"{path.name}/" if path.is_dir() else path.name
        entries.append(name)
        if len(entries) >= limit:
            break
    return entries


def _detect_commands(
    root: Path, package_json: Dict[str, object], pyproject_text: str
) -> List[str]:
    commands: List[str] = []
    has_tests = _has_tests(root)
    if package_json:
        commands.append("npm install")
        scripts = package_json.get("scripts", {})
        if isinstance(scripts, dict):
            for name in scripts.keys():
                commands.append(f"npm run {name}")
    if (root / "pyproject.toml").exists() or (root / "poetry.lock").exists():
        commands.append("poetry install")
        if has_tests:
            commands.append("poetry run pytest")
    if (root / "requirements.txt").exists():
        commands.append("pip install -r requirements.txt")
        if has_tests:
            commands.append("pytest")
    if (root / "Makefile").exists():
        make_targets = _parse_make_targets(_read_text(root / "Makefile"))
        for target in make_targets:
            commands.append(f"make {target}")
    if list(root.glob("docker-compose*.yml")):
        commands.append("docker compose up")

    return _unique_preserve(commands, limit=12)


def _has_tests(root: Path) -> bool:
    return (root / "tests").exists() or (root / "pytest.ini").exists()


def _parse_make_targets(text: str) -> List[str]:
    targets: List[str] = []
    for raw_line in text.splitlines():
        if not raw_line or raw_line.startswith("\t"):
            continue
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        match = re.match(r"^([A-Za-z0-9][A-Za-z0-9_.-]*)\s*:", line)
        if not match:
            continue
        target = match.group(1)
        if target.startswith(".") or "%" in target or target == "PHONY":
            continue
        if target not in targets:
            targets.append(target)
    return targets[:10]


def _unique_preserve(items: Iterable[str], limit: int = 12) -> List[str]:
    seen = set()
    unique: List[str] = []
    for item in items:
        if item in seen or not item:
            continue
        seen.add(item)
        unique.append(item)
        if len(unique) >= limit:
            break
    return unique
